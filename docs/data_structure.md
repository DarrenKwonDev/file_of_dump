

<!-- toc -->

- [자구](#%EC%9E%90%EA%B5%AC)
- [자구 종류](#%EC%9E%90%EA%B5%AC-%EC%A2%85%EB%A5%98)
  * [배열, 스택, 링큐, 덱](#%EB%B0%B0%EC%97%B4-%EC%8A%A4%ED%83%9D-%EB%A7%81%ED%81%90-%EB%8D%B1)
  * [linked list](#linked-list)
  * [hash table](#hash-table)
    + [색인 추출 및 색인 충돌](#%EC%83%89%EC%9D%B8-%EC%B6%94%EC%B6%9C-%EB%B0%8F-%EC%83%89%EC%9D%B8-%EC%B6%A9%EB%8F%8C)
    + [해시와 해시 충돌](#%ED%95%B4%EC%8B%9C%EC%99%80-%ED%95%B4%EC%8B%9C-%EC%B6%A9%EB%8F%8C)
  * [tree](#tree)
  * [graph](#graph)

<!-- tocstop -->

## 자구

자구 : 동일한 자료형을 여럿 저장하는 구조
알고리즘은 자료구조에 의존적.

효율성 : 시간 복잡도와 공간 복잡도. 일반적으로 '최악의 복잡도'를 말함.

자구 선택 기준 :

1. 데이터에 접근하는 빈도
2. 데이터에 접근하는 방법(삽입, 삭제, 검색, 읽기[접근])

## 자구 종류

### 배열, 스택, 링큐, 덱

### linked list

최대 길이를 알 수 없고 삽입/삭제가 빈번한 경우
현대 어플리케이션에서의 사용 빈도는 줄어듦. 동적 할당 배열을 더 많이 사용함.
임베디드, kernel 레벨에서는 종종 보임.

### hash table

배열에 특정 값을 루프를 돌지 않으며 O(1)으로 찾는 방법 -> 해시 테이블의 등장 과정.

hash table에 저장하는 과정

```c
입력값 -> 해시함수 -> 해시값 -> 소수로 나누기 -> 색인 -> 저장
```

#### 색인 추출 및 색인 충돌

`1안. 값을 색인으로 사용하기`
예를 들면, 724가 배열에 존재하는 지의 여부를 아래처럼 판단.
arr[724] = 1 or 0 (724의 존재 여부)
값이 커짐에 따라 배열 크기도 선형적 증가.
메모리 낭비 심함. 기각.

`2안. 소수로 나눈 값을 색인으로 사용하기`
예를 들면, [72, 81]을 소수인 7로 나누어 각각 나머지인 2, 4를 색인으로써 사용하자는 것.
중복 색인이 발생하는 문제.

`2안 보완. 색인 충돌 해결 방법`

1. bool 배열(혹은 가능하지 않은 값을 넣은)을 만들어서 이미 찬 곳은 넘고, 빈 곳에 넣는다.
2. 배열이 linked list여서 여러 값을 저장하게 만들자.
   예를 들어 이런 것.
   idx
   1 -> [8, 15]
   2 -> [9, 110]
   3 -> [3, 22, 45]

#### 해시와 해시 충돌

`해시 함수`

-   임의값을 고정된 크기로 출력하는 함수.
-   근본 질문인 '배열에 특정 값을 루프를 돌지 않으며 O(1)으로 찾는 방법'을 위해서는 시간 복잡도가 O(1) 이어야 함.
-   수학적으로 해시 충돌은 발생함. 그러나 최근의 해시 알고리즘은 해시 충돌 확률이 극히 낮으며 특정 조건 하에는 방지 가능.

해시 함수 종류 : 65599, MD, SHA, Argon2, FNV-1 ... 아주 많음. 속도가 빠르면 충돌 확률이 높고 느릴 수록 충돌 확률이 낮음.

`해시 충돌이 나면?`

선형 탐색으로 빈 곳을 찾아야 함. O(1)을 의도한 해시 테이블이었으나 해시 충돌 발생시 다른 곳을 찾아 이동해야 하므로 O(n)의 선형 탐색이 필요함. 결국 해시 테이블 자료 구조의 장점을 잃게 됨. 그래서 해시 충돌이 가급적 일어나지 않아야함.

`해시 충돌 해결 방법`

해시 충돌 : 키가 다른데 같은 해시값이 나옴
색인 충돌 : 해시값은 다른데 같은 색인이 나옴

순서 상으로 해시값이 값으면 당연히 색인 충돌도 발생함.
그러나 해시 충돌 문제를 해결해야 하나? 사실 색인 충돌 해결 방식으로 같이 해결된다.
하지만 해시 충돌을 방지하면 성능 이득이 있다. 해시가 발생하면 본래 입력값과 해시값 둘 다 알아야 하는데 해시 충돌이 없다면 해시값만 알면 되기 때문이다.

`해시 충돌을 방지할 수 있는 조건?`

데이터가 한정된 경우 (유저 입력을 받아 데이터가 워낙 많이 들어와 충돌 가능성이 있지만 한정된 데이터만으로 해시 함수를 돌리는 경우는 가능)

### tree

### graph
